//
//  CoveringArray.cpp
//  CSE 430 Individual Project 1
//
//  Created by Gregory Moon on 1/22/15.
//  Copyright (c) 2015 Gregory Moon. All rights reserved.
//

#include "CoveringArray.h"

//nothing
#include <string>

CoveringArray::CoveringArray(std::vector<std::vector<int>> values, int colsInSubArray, int numDistinctElements){
    this->values = values;
    this->columns.resize(values[0].size());
    
    this->createColumns();
    
    this->occurenceArray = new OccurenceArray(this->columns, colsInSubArray, numDistinctElements);
    
    if(this->validCoveringArray()){
        this->occurenceLocationArray = new OccurenceLocationArray(values, this->occurenceArray->getTable());
        this->modifyOriginal();
    }
}   //end constructor

/*
 validCoveringArray:
    This method checks to make sure that the array being considered is a actually a covering array and returns a boolean value indicating whether it is valid or not.

    output:
        true if the array is a covering array, false if it is not
 */

bool CoveringArray::validCoveringArray(){
    return this->occurenceArray->validCoveringArray();
}   //end validCoveringArray

/*
 createColumns:
    This method simply creates objects of the Column class to represent the 2d array
 */

void CoveringArray::createColumns(){
    for(int i = 0; i < this->columns.size(); i++){
        this->columns[i] = new Column(this->values.size());
        
        for(int j = 0; j < this->values.size(); j++)
            this->columns[i]->add(this->values[j][i]);
    }
}   //end createColumns

/*
 modifyOriginal:
    This method looks through the counts generated by the occurenceLocationArray and identifies the potential don't-care positions in the array. If the count at a particular location is 0, then the 0 is replaced with an asterisk (*) to signify a don't-care position.
 */

void CoveringArray::modifyOriginal(){
    std::vector<std::vector<int>> arrToCheck = occurenceLocationArray->getCounts();
    this->modifiedValues.resize(arrToCheck.size());
    
    
    for(int i = 0; i < arrToCheck.size(); i++){
        std::vector<string> newVec(arrToCheck[i].size());
        this->modifiedValues[i] = newVec;
        for(int j = 0; j < arrToCheck[i].size(); j++){
            if(arrToCheck[i][j] == 0){
                this->modifiedValues[i][j] = "*";
                this->dontCarePositions.push_back({i, j});
            }
            else{
                int value = values[i][j];
                string charToAdd = std::to_string(value);
                modifiedValues[i][j] = charToAdd;
            }
        }
    }
}	//end modifyOriginal

/*
 getModifiedValues:
    A getter for the modifiedValues array
    
    output:
        a 2d array of strings
 */

std::vector<std::vector<std::string>> CoveringArray::getModifiedValues(){
    return this->modifiedValues;
}   //end getModifiedValues

std::vector<std::vector<int>> CoveringArray::getDontCarePositions(){
    return this->dontCarePositions;
}

